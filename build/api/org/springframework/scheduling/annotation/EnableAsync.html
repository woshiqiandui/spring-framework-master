<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="zh">
<head>
<!-- Generated by javadoc (1.8.0_191) on Sat Dec 01 12:20:17 CST 2018 -->
<title>EnableAsync (Spring Framework 5.1.4.BUILD-SNAPSHOT API)</title>
<meta name="date" content="2018-12-01">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="EnableAsync (Spring Framework 5.1.4.BUILD-SNAPSHOT API)";
        }
    }
    catch(err) {
    }
//-->
</script>
<noscript>
<div>您的浏览器已禁用 JavaScript。</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="跳过导航链接">跳过导航链接</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="导航">
<li><a href="../../../../overview-summary.html">概览</a></li>
<li><a href="package-summary.html">程序包</a></li>
<li class="navBarCell1Rev">类</li>
<li><a href="class-use/EnableAsync.html">使用</a></li>
<li><a href="package-tree.html">树</a></li>
<li><a href="../../../../deprecated-list.html">已过时</a></li>
<li><a href="../../../../index-files/index-1.html">索引</a></li>
<li><a href="../../../../help-doc.html">帮助</a></li>
</ul>
<div class="aboutLanguage">Spring Framework</div>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../org/springframework/scheduling/annotation/AsyncResult.html" title="org.springframework.scheduling.annotation中的类"><span class="typeNameLink">上一个类</span></a></li>
<li><a href="../../../../org/springframework/scheduling/annotation/EnableScheduling.html" title="org.springframework.scheduling.annotation中的注释"><span class="typeNameLink">下一个类</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?org/springframework/scheduling/annotation/EnableAsync.html" target="_top">框架</a></li>
<li><a href="EnableAsync.html" target="_top">无框架</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../allclasses-noframe.html">所有类</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>概要:&nbsp;</li>
<li>字段&nbsp;|&nbsp;</li>
<li>必需&nbsp;|&nbsp;</li>
<li><a href="#annotation.type.optional.element.summary">可选</a></li>
</ul>
<ul class="subNavList">
<li>详细资料:&nbsp;</li>
<li>字段&nbsp;|&nbsp;</li>
<li><a href="#annotation.type.element.detail">元素</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">org.springframework.scheduling.annotation</div>
<h2 title="注释类型 EnableAsync" class="title">注释类型 EnableAsync</h2>
</div>
<div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>@Target(value=TYPE)
 @Retention(value=RUNTIME)
 @Documented
 <a href="../../../../org/springframework/context/annotation/Import.html" title="org.springframework.context.annotation中的注释">@Import</a>(<a href="../../../../org/springframework/context/annotation/Import.html#value--">value</a>=<a href="../../../../org/springframework/scheduling/annotation/AsyncConfigurationSelector.html" title="org.springframework.scheduling.annotation中的类">AsyncConfigurationSelector.class</a>)
public @interface <span class="memberNameLabel">EnableAsync</span></pre>
<div class="block">Enables Spring's asynchronous method execution capability, similar to functionality
 found in Spring's <code>&lt;task:*&gt;</code> XML namespace.

 <p>To be used together with @<a href="../../../../org/springframework/context/annotation/Configuration.html" title="org.springframework.context.annotation中的注释"><code>Configuration</code></a> classes as follows,
 enabling annotation-driven async processing for an entire Spring application context:

 <pre class="code">
 &#064;Configuration
 &#064;EnableAsync
 public class AppConfig {

 }</pre>

 <code>MyAsyncBean</code> is a user-defined type with one or more methods annotated with
 either Spring's <code>@Async</code> annotation, the EJB 3.1 <code>@javax.ejb.Asynchronous</code>
 annotation, or any custom annotation specified via the <a href="../../../../org/springframework/scheduling/annotation/EnableAsync.html#annotation--"><code>annotation()</code></a> attribute.
 The aspect is added transparently for any registered bean, for instance via this
 configuration:

 <pre class="code">
 &#064;Configuration
 public class AnotherAppConfig {

     &#064;Bean
     public MyAsyncBean asyncBean() {
         return new MyAsyncBean();
     }
 }</pre>

 <p>By default, Spring will be searching for an associated thread pool definition:
 either a unique <a href="../../../../org/springframework/core/task/TaskExecutor.html" title="org.springframework.core.task中的接口"><code>TaskExecutor</code></a> bean in the context,
 or an <code>Executor</code> bean named "taskExecutor" otherwise. If
 neither of the two is resolvable, a <a href="../../../../org/springframework/core/task/SimpleAsyncTaskExecutor.html" title="org.springframework.core.task中的类"><code>SimpleAsyncTaskExecutor</code></a>
 will be used to process async method invocations. Besides, annotated methods having a
 <code>void</code> return type cannot transmit any exception back to the caller. By default,
 such uncaught exceptions are only logged.

 <p>To customize all this, implement <a href="../../../../org/springframework/scheduling/annotation/AsyncConfigurer.html" title="org.springframework.scheduling.annotation中的接口"><code>AsyncConfigurer</code></a> and provide:
 <ul>
 <li>your own <code>Executor</code> through the
 <a href="../../../../org/springframework/scheduling/annotation/AsyncConfigurer.html#getAsyncExecutor--"><code>getAsyncExecutor()</code></a> method, and</li>
 <li>your own <a href="../../../../org/springframework/aop/interceptor/AsyncUncaughtExceptionHandler.html" title="org.springframework.aop.interceptor中的接口"><code>AsyncUncaughtExceptionHandler</code></a> through the <a href="../../../../org/springframework/scheduling/annotation/AsyncConfigurer.html#getAsyncUncaughtExceptionHandler--"><code>getAsyncUncaughtExceptionHandler()</code></a>
 method.</li>
 </ul>

 <p><b>NOTE: <a href="../../../../org/springframework/scheduling/annotation/AsyncConfigurer.html" title="org.springframework.scheduling.annotation中的接口"><code>AsyncConfigurer</code></a> configuration classes get initialized early
 in the application context bootstrap. If you need any dependencies on other beans
 there, make sure to declare them 'lazy' as far as possible in order to let them
 go through other post-processors as well.</b>

 <pre class="code">
 &#064;Configuration
 &#064;EnableAsync
 public class AppConfig implements AsyncConfigurer {

     &#064;Override
     public Executor getAsyncExecutor() {
         ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
         executor.setCorePoolSize(7);
         executor.setMaxPoolSize(42);
         executor.setQueueCapacity(11);
         executor.setThreadNamePrefix("MyExecutor-");
         executor.initialize();
         return executor;
     }

     &#064;Override
     public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
         return MyAsyncUncaughtExceptionHandler();
     }
 }</pre>

 <p>If only one item needs to be customized, <code>null</code> can be returned to
 keep the default settings. Consider also extending from <a href="../../../../org/springframework/scheduling/annotation/AsyncConfigurerSupport.html" title="org.springframework.scheduling.annotation中的类"><code>AsyncConfigurerSupport</code></a>
 when possible.

 <p>Note: In the above example the <code>ThreadPoolTaskExecutor</code> is not a fully managed
 Spring bean. Add the <code>@Bean</code> annotation to the <code>getAsyncExecutor()</code> method
 if you want a fully managed bean. In such circumstances it is no longer necessary to
 manually call the <code>executor.initialize()</code> method as this will be invoked
 automatically when the bean is initialized.

 <p>For reference, the example above can be compared to the following Spring XML
 configuration:

 <pre class="code">
 &lt;beans&gt;

     &lt;task:annotation-driven executor="myExecutor" exception-handler="exceptionHandler"/&gt;

     &lt;task:executor id="myExecutor" pool-size="7-42" queue-capacity="11"/&gt;

     &lt;bean id="asyncBean" class="com.foo.MyAsyncBean"/&gt;

     &lt;bean id="exceptionHandler" class="com.foo.MyAsyncUncaughtExceptionHandler"/&gt;

 &lt;/beans&gt;
 </pre>

 The above XML-based and JavaConfig-based examples are equivalent except for the
 setting of the <em>thread name prefix</em> of the <code>Executor</code>; this is because
 the <code>&lt;task:executor&gt;</code> element does not expose such an attribute. This
 demonstrates how the JavaConfig-based approach allows for maximum configurability
 through direct access to actual componentry.

 <p>The <a href="../../../../org/springframework/scheduling/annotation/EnableAsync.html#mode--"><code>mode()</code></a> attribute controls how advice is applied: If the mode is
 <a href="../../../../org/springframework/context/annotation/AdviceMode.html#PROXY"><code>AdviceMode.PROXY</code></a> (the default), then the other attributes control the behavior
 of the proxying. Please note that proxy mode allows for interception of calls through
 the proxy only; local calls within the same class cannot get intercepted that way.

 <p>Note that if the <a href="../../../../org/springframework/scheduling/annotation/EnableAsync.html#mode--">mode()</a> is set to <a href="../../../../org/springframework/context/annotation/AdviceMode.html#ASPECTJ"><code>AdviceMode.ASPECTJ</code></a>, then the
 value of the <a href="../../../../org/springframework/scheduling/annotation/EnableAsync.html#proxyTargetClass--"><code>proxyTargetClass()</code></a> attribute will be ignored. Note also that in
 this case the <code>spring-aspects</code> module JAR must be present on the classpath, with
 compile-time weaving or load-time weaving applying the aspect to the affected classes.
 There is no proxy involved in such a scenario; local calls will be intercepted as well.</div>
<dl>
<dt><span class="simpleTagLabel">从以下版本开始:</span></dt>
<dd>3.1</dd>
<dt><span class="simpleTagLabel">作者:</span></dt>
<dd>Chris Beams, Juergen Hoeller, Stephane Nicoll, Sam Brannen</dd>
<dt><span class="seeLabel">另请参阅:</span></dt>
<dd><a href="../../../../org/springframework/scheduling/annotation/Async.html" title="org.springframework.scheduling.annotation中的注释"><code>Async</code></a>, 
<a href="../../../../org/springframework/scheduling/annotation/AsyncConfigurer.html" title="org.springframework.scheduling.annotation中的接口"><code>AsyncConfigurer</code></a>, 
<a href="../../../../org/springframework/scheduling/annotation/AsyncConfigurationSelector.html" title="org.springframework.scheduling.annotation中的类"><code>AsyncConfigurationSelector</code></a></dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== ANNOTATION TYPE OPTIONAL MEMBER SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="annotation.type.optional.element.summary">
<!--   -->
</a>
<h3>可选元素概要</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="可选元素概要表, 列表可选元素和解释">
<caption><span>可选元素</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">限定符和类型</th>
<th class="colLast" scope="col">可选元素和说明</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/springframework/scheduling/annotation/EnableAsync.html#annotation--">annotation</a></span></code>
<div class="block">Indicate the 'async' annotation type to be detected at either class
 or method level.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../../org/springframework/context/annotation/AdviceMode.html" title="org.springframework.context.annotation中的枚举">AdviceMode</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/springframework/scheduling/annotation/EnableAsync.html#mode--">mode</a></span></code>
<div class="block">Indicate how async advice should be applied.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/springframework/scheduling/annotation/EnableAsync.html#order--">order</a></span></code>
<div class="block">Indicate the order in which the <a href="../../../../org/springframework/scheduling/annotation/AsyncAnnotationBeanPostProcessor.html" title="org.springframework.scheduling.annotation中的类"><code>AsyncAnnotationBeanPostProcessor</code></a>
 should be applied.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../../org/springframework/scheduling/annotation/EnableAsync.html#proxyTargetClass--">proxyTargetClass</a></span></code>
<div class="block">Indicate whether subclass-based (CGLIB) proxies are to be created as opposed
 to standard Java interface-based proxies.</div>
</td>
</tr>
</table>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ ANNOTATION TYPE MEMBER DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="annotation.type.element.detail">
<!--   -->
</a>
<h3>元素详细资料</h3>
<a name="annotation--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>annotation</h4>
<pre>public abstract&nbsp;java.lang.Class&lt;? extends java.lang.annotation.Annotation&gt;&nbsp;annotation</pre>
<div class="block">Indicate the 'async' annotation type to be detected at either class
 or method level.
 <p>By default, both Spring's @<a href="../../../../org/springframework/scheduling/annotation/Async.html" title="org.springframework.scheduling.annotation中的注释"><code>Async</code></a> annotation and the EJB 3.1
 <code>@javax.ejb.Asynchronous</code> annotation will be detected.
 <p>This attribute exists so that developers can provide their own
 custom annotation type to indicate that a method (or all methods of
 a given class) should be invoked asynchronously.</div>
<dl>
<dt>默认值:</dt>
<dd>java.lang.annotation.Annotation.class</dd>
</dl>
</li>
</ul>
</li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="proxyTargetClass--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>proxyTargetClass</h4>
<pre>public abstract&nbsp;boolean&nbsp;proxyTargetClass</pre>
<div class="block">Indicate whether subclass-based (CGLIB) proxies are to be created as opposed
 to standard Java interface-based proxies.
 <p><strong>Applicable only if the <a href="../../../../org/springframework/scheduling/annotation/EnableAsync.html#mode--"><code>mode()</code></a> is set to <a href="../../../../org/springframework/context/annotation/AdviceMode.html#PROXY"><code>AdviceMode.PROXY</code></a></strong>.
 <p>The default is <code>false</code>.
 <p>Note that setting this attribute to <code>true</code> will affect <em>all</em>
 Spring-managed beans requiring proxying, not just those marked with <code>@Async</code>.
 For example, other beans marked with Spring's <code>@Transactional</code> annotation
 will be upgraded to subclass proxying at the same time. This approach has no
 negative impact in practice unless one is explicitly expecting one type of proxy
 vs. another &mdash; for example, in tests.</div>
<dl>
<dt>默认值:</dt>
<dd>false</dd>
</dl>
</li>
</ul>
</li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="mode--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mode</h4>
<pre>public abstract&nbsp;<a href="../../../../org/springframework/context/annotation/AdviceMode.html" title="org.springframework.context.annotation中的枚举">AdviceMode</a>&nbsp;mode</pre>
<div class="block">Indicate how async advice should be applied.
 <p><b>The default is <a href="../../../../org/springframework/context/annotation/AdviceMode.html#PROXY"><code>AdviceMode.PROXY</code></a>.</b>
 Please note that proxy mode allows for interception of calls through the proxy
 only. Local calls within the same class cannot get intercepted that way; an
 <a href="../../../../org/springframework/scheduling/annotation/Async.html" title="org.springframework.scheduling.annotation中的注释"><code>Async</code></a> annotation on such a method within a local call will be ignored
 since Spring's interceptor does not even kick in for such a runtime scenario.
 For a more advanced mode of interception, consider switching this to
 <a href="../../../../org/springframework/context/annotation/AdviceMode.html#ASPECTJ"><code>AdviceMode.ASPECTJ</code></a>.</div>
<dl>
<dt>默认值:</dt>
<dd>org.springframework.context.annotation.AdviceMode.PROXY</dd>
</dl>
</li>
</ul>
</li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="order--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>order</h4>
<pre>public abstract&nbsp;int&nbsp;order</pre>
<div class="block">Indicate the order in which the <a href="../../../../org/springframework/scheduling/annotation/AsyncAnnotationBeanPostProcessor.html" title="org.springframework.scheduling.annotation中的类"><code>AsyncAnnotationBeanPostProcessor</code></a>
 should be applied.
 <p>The default is <a href="../../../../org/springframework/core/Ordered.html#LOWEST_PRECEDENCE"><code>Ordered.LOWEST_PRECEDENCE</code></a> in order to run
 after all other post-processors, so that it can add an advisor to
 existing proxies rather than double-proxy.</div>
<dl>
<dt>默认值:</dt>
<dd>2147483647</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="跳过导航链接">跳过导航链接</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="导航">
<li><a href="../../../../overview-summary.html">概览</a></li>
<li><a href="package-summary.html">程序包</a></li>
<li class="navBarCell1Rev">类</li>
<li><a href="class-use/EnableAsync.html">使用</a></li>
<li><a href="package-tree.html">树</a></li>
<li><a href="../../../../deprecated-list.html">已过时</a></li>
<li><a href="../../../../index-files/index-1.html">索引</a></li>
<li><a href="../../../../help-doc.html">帮助</a></li>
</ul>
<div class="aboutLanguage">Spring Framework</div>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../../org/springframework/scheduling/annotation/AsyncResult.html" title="org.springframework.scheduling.annotation中的类"><span class="typeNameLink">上一个类</span></a></li>
<li><a href="../../../../org/springframework/scheduling/annotation/EnableScheduling.html" title="org.springframework.scheduling.annotation中的注释"><span class="typeNameLink">下一个类</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../../index.html?org/springframework/scheduling/annotation/EnableAsync.html" target="_top">框架</a></li>
<li><a href="EnableAsync.html" target="_top">无框架</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../allclasses-noframe.html">所有类</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>概要:&nbsp;</li>
<li>字段&nbsp;|&nbsp;</li>
<li>必需&nbsp;|&nbsp;</li>
<li><a href="#annotation.type.optional.element.summary">可选</a></li>
</ul>
<ul class="subNavList">
<li>详细资料:&nbsp;</li>
<li>字段&nbsp;|&nbsp;</li>
<li><a href="#annotation.type.element.detail">元素</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
